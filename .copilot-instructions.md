# Copilot Instructions for NDMF (Non-Destructive Modular Framework)

## Project Overview

NDMF is a framework for building non-destructive editor plugins for VRChat avatars. It provides a sophisticated plugin execution system based on phases, passes, and dependency ordering to ensure predictable and reliable avatar processing.

## Architecture & Key Concepts

### Core Components

1. **Plugins** (`Plugin<T>`) - End-user-visible extensions (e.g., Modular Avatar, AAO)
2. **Passes** (`Pass`) - Internal execution steps within plugins for fine-grained control
3. **Build Phases** - Ordered execution stages:
   - `Resolving` - Pre-transformation state rehydration
   - `Generating` - Object/component generation
   - `Transforming` - Main avatar modification phase
   - `Optimizing` - Performance optimizations
4. **BuildContext** - Central context object passed to all passes
5. **Extension Contexts** - Shared services across multiple passes (e.g., animation path tracking)

### Plugin Structure Pattern

All plugins follow this basic structure:
```csharp
[assembly: ExportsPlugin(typeof(MyPlugin))]

public class MyPlugin : Plugin<MyPlugin>
{
    public override string QualifiedName => "com.example.my-plugin";
    public override string DisplayName => "My Plugin Name";
    
    protected override void Configure()
    {
        InPhase(BuildPhase.Transforming)
            .Run("Pass name", ctx => {
                // Pass implementation
            });
    }
}
```

### Dependency Declaration Patterns

Use fluent API for dependency ordering:
```csharp
InPhase(BuildPhase.Transforming)
    .AfterPlugin("com.example.some-plugin")
    .BeforePlugin(typeof(SomeMandatoryPlugin))
    .AfterPass(typeof(SomePass))
    .WaitFor(typeof(RunsJustBeforePass))
    .Run("My pass", ctx => { /* ... */ });
```

## File Organization

- `Editor/` - Editor-only code (plugins, UI, build logic)
- `Runtime/` - Runtime components and utilities  
- `UnitTests~/` - Unit tests (follows `~` Unity convention for test assemblies)
- `Editor/Samples~/` - Sample plugin implementations
- `Editor/API/` - Public API definitions
- `docfx~/` - Documentation source files

## Coding Standards

### API Design Principles
- **Avoid New Public APIs**: Create new public APIs only when explicitly requested in issues
- **Use Internal APIs**: Prefer `internal` APIs for functionality not intended for external use
- **API Documentation**: Always call out any new or changed public APIs in pull request descriptions
- **Breaking Changes**: Minimize breaking changes to existing public APIs

### VRCSDK Dependencies
- Code depending on VRCSDK must use conditional compilation with versionDefines
- Alternatively, place VRCSDK-specific code in conditionally-included asmdef files
- This applies to unit tests as well as runtime/editor code
- Example conditional compilation:
```csharp
#if VRCSDK3_AVATARS
    // VRCSDK-dependent code here
#endif
```

### Naming Conventions
- Use PascalCase for public members, types, and namespaces
- Use camelCase for private/protected fields (with underscore prefix `_field`)
- Plugin qualified names use reverse domain notation: `"com.vendor.plugin-name"`

### Code Style
- Use `#region` blocks for using statements at file top
- Include XML documentation for public APIs
- Use `[PublicAPI]` attribute from JetBrains.Annotations for public API surfaces
- Mark internal-only APIs with `[NDMFInternal]` attribute

### Error Handling
- Use `ErrorReport` system for user-facing errors
- Provide localization support via `InlineError` with localization keys
- Include context objects (`ObjectReference`) for error reporting

### Unity Patterns
- Use `ScriptableSingleton<T>` for editor settings/config
- Follow Unity package structure with `.asmdef` files
- Use Unity's `[SerializeField]` for serialized data

## Testing Approach

### Unit Test Structure
- Tests in `UnitTests~/` directory
- Use NUnit framework (`[Test]` attribute)
- Test naming: `TestMethodName()` describing the scenario
- Include setup/teardown as needed for Unity object lifecycle

### Test Categories
- Core API functionality tests
- Plugin execution order tests  
- Build context state management tests
- Error reporting and localization tests

### Example Test Pattern
```csharp
[Test]
public void TestPluginExecution()
{
    // Arrange
    var context = CreateTestBuildContext();
    
    // Act
    RunPlugin(context);
    
    // Assert
    Assert.AreEqual(expectedValue, context.GetState<TestState>().Value);
}
```

## Common Development Workflows

### Adding a New Plugin
1. Create plugin class inheriting from `Plugin<T>`
2. Implement `Configure()` method with phase declarations
3. Add `[assembly: ExportsPlugin(typeof(Plugin))]` attribute
4. Add unit tests for plugin functionality
5. Document any new public APIs
6. Update `CHANGELOG.md` and `CHANGELOG-PRERELEASE.md` with PR number citation

### Adding Extension Contexts
1. Implement `IExtensionContext` interface
2. Define context activation/deactivation logic
3. Update passes to declare required/compatible contexts
4. Add context to extension registry
5. Update changelog with PR number citation

## Documentation & Change Management

### Changelog Requirements
- All code changes must be documented in `CHANGELOG.md` and `CHANGELOG-PRERELEASE.md`
- Documentation-only changes do not need changelog entries
- Changelog entries must cite the PR number that fixed the issue
- Format: `- [Feature/Fix]: Description (#PR_NUMBER)`

### Public API Changes
- New public APIs require explicit justification in PR descriptions
- Breaking changes need version bump consideration
- Use `[PublicAPI]` attribute for public API surfaces
- Mark internal-only APIs with `[NDMFInternal]` attribute

### Debugging Execution Order
- Use `#if NDMF_INTERNAL_DEBUG` for debug output
- Plugin resolver logs constraint graphs in debug builds
- Check GameCI workflow logs for test execution details

## Platform Support

- Primary: VRChat platform via VRCSDK
- Experimental: Standalone platform support
- Use `[RunsOnAllPlatforms]` or platform-specific constraints
- Platform providers implement `INDMFPlatformProvider`

## Build & CI Information

### Local Development
- Unity 2022.3.6f1+ required
- Use Unity Package Manager for dependencies
- Run tests via Unity Test Runner (EditMode)

### CI Pipeline (GameCI)
- Automated testing on Unity 2022.3.6f1
- Both VRCSDK and standalone builds
- Coverage reports generated
- Test artifacts uploaded for debugging

### Package Distribution
- Unity Package Manager format
- Semantic versioning (see `docfx~/versioning-policy.md`)
- Automated release builds via GitHub Actions

## Key Dependencies & Integrations

- **VRChat SDK** - Avatar descriptor and build pipeline integration
- **Unity Animation System** - Animation path tracking and modification
- **Harmony** - Runtime patching for Unity editor integration
- **Localization System** - Multi-language error reporting

### Primary Consumer Projects

- **Modular Avatar** (https://github.com/bdunderscore/modular-avatar) - The primary consumer of NDMF
  - Use Modular Avatar's codebase as a reference for real-world NDMF usage patterns
  - Test code changes against Modular Avatar's CI test suite when possible
  - Follow patterns established in Modular Avatar for plugin development

## Common Patterns to Follow

1. **State Management**: Use `BuildContext.GetState<T>()` for pass-to-pass communication
2. **Error Reporting**: Use `ErrorReport.ReportError()` with proper context objects
3. **Asset Management**: Use `AssetSaver` for generated asset cleanup
4. **Animation Handling**: Use animation services for path tracking
5. **Object Tracking**: Use `ObjectRegistry` for cross-pass object references

## Debugging Tips

- Enable `NDMF_INTERNAL_DEBUG` for verbose logging
- Check constraint graphs for dependency issues  
- Use Unity Profiler for performance analysis
- Review GameCI logs for test failures
- Use error reporting system for user-friendly diagnostics

This framework emphasizes predictable execution order, robust error handling, and extensibility while maintaining backwards compatibility.