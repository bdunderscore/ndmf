# Copilot Instructions for NDMF (Non-Destructive Modular Framework)

## Project Overview

NDMF is a framework for building non-destructive editor plugins for VRChat avatars. It provides a sophisticated plugin execution system based on phases, passes, and dependency ordering to ensure predictable and reliable avatar processing.

## Architecture & Key Concepts

### Core Components

1. **Plugins** (`Plugin<T>`) - End-user-visible extensions (e.g., Modular Avatar, AAO)
2. **Passes** (`Pass`) - Internal execution steps within plugins for fine-grained control
3. **Build Phases** - Ordered execution stages:
   - `Resolving` - Pre-transformation state rehydration
   - `Generating` - Object/component generation
   - `Transforming` - Main avatar modification phase
   - `Optimizing` - Performance optimizations
4. **BuildContext** - Central context object passed to all passes
5. **Extension Contexts** - Shared services across multiple passes (e.g., animation path tracking)

### Plugin Structure Pattern

All plugins follow this basic structure:
```csharp
[assembly: ExportsPlugin(typeof(MyPlugin))]

public class MyPlugin : Plugin<MyPlugin>
{
    public override string QualifiedName => "com.example.my-plugin";
    public override string DisplayName => "My Plugin Name";
    
    protected override void Configure()
    {
        InPhase(BuildPhase.Transforming)
            .Run("Pass name", ctx => {
                // Pass implementation
            });
    }
}
```

### Dependency Declaration Patterns

Use fluent API for dependency ordering:
```csharp
InPhase(BuildPhase.Transforming)
    .AfterPlugin("com.example.some-plugin")
    .BeforePlugin(typeof(SomeMandatoryPlugin))
    .AfterPass(typeof(SomePass))
    .WaitFor(typeof(RunsJustBeforePass))
    .Run("My pass", ctx => { /* ... */ });
```

## File Organization

- `Editor/` - Editor-only code (plugins, UI, build logic)
- `Runtime/` - Runtime components and utilities  
- `UnitTests~/` - Unit tests (follows `~` Unity convention for test assemblies)
- `Editor/Samples~/` - Sample plugin implementations
- `Editor/API/` - Public API definitions
- `docfx~/` - Documentation source files

## Coding Standards

### API Design Principles
- **Avoid New Public APIs**: Create new public APIs only when explicitly requested in issues
- **Use Internal APIs**: Prefer `internal` APIs for functionality not intended for external use
- **API Documentation**: Always call out any new or changed public APIs in pull request descriptions
- **Breaking Changes**: Minimize breaking changes to existing public APIs

### VRCSDK Dependencies
- Code depending on VRCSDK must use conditional compilation with versionDefines
- Alternatively, place VRCSDK-specific code in conditionally-included asmdef files
- This applies to unit tests as well as runtime/editor code
- Example conditional compilation:
```csharp
#if VRCSDK3_AVATARS
    // VRCSDK-dependent code here
#endif
```

### Naming Conventions
- Use PascalCase for public members, types, and namespaces
- Use camelCase for private/protected fields (with underscore prefix `_field`)
- Plugin qualified names use reverse domain notation: `"com.vendor.plugin-name"`

### Code Style
- Use `#region` blocks for using statements at file top
- Include XML documentation for public APIs
- Use `[PublicAPI]` attribute from JetBrains.Annotations for public API surfaces
- Mark internal-only APIs with `[NDMFInternal]` attribute

### Error Handling
- Use `ErrorReport` system for user-facing errors
- Provide localization support via `InlineError` with localization keys
- Include context objects (`ObjectReference`) for error reporting

### Unity Patterns
- Use `ScriptableSingleton<T>` for editor settings/config
- Follow Unity package structure with `.asmdef` files
- Use Unity's `[SerializeField]` for serialized data

## Testing Approach

### Unit Test Structure
- Tests in `UnitTests~/` directory (note the `~` suffix for Unity test assemblies)
- Use NUnit framework (`[Test]` attribute)
- Test naming: `TestMethodName()` describing the scenario
- Assembly definition: `nadena.dev.ndmf.UnitTests.asmdef` with Editor-only platform targeting
- Include setup/teardown as needed for Unity object lifecycle

### Running Tests Locally

#### Prerequisites
- Unity 2022.3.6f1 or newer
- VRChat SDK (for VRCSDK-dependent tests) or standalone mode

#### Setup for Local Testing
1. **With VRCSDK dependencies** (recommended):
   - Install VRChat SDK through VCC (VRChat Creator Companion)
   - Or use `vrc-get` CLI tool for package resolution

2. **Standalone mode** (experimental):
   - Run `SetupStandalone.ps1` to create dependency symlinks
   - Run `SetupUnitTests.ps1` to create UnitTests symlink from UnitTests~

#### Running Tests
- **Unity Test Runner**: Window → General → Test Runner
- Select "EditMode" tab
- Filter by assembly: `nadena.dev.ndmf.UnitTests`
- Click "Run All" or select specific tests

#### Command Line Testing (CI-style)
The CI uses GameCI Unity Test Runner with these parameters:
```bash
Unity -testMode EditMode -nographics -assemblyNames nadena.dev.ndmf.UnitTests
```

### Test Categories
- **Core API functionality** - Plugin registration, BuildContext operations
- **Plugin execution order** - Dependency resolution and phase ordering
- **Build context state management** - State persistence across passes
- **Error reporting and localization** - ErrorReport system functionality
- **Animation services** - Path tracking and modification
- **Extension contexts** - Context activation/deactivation lifecycle

### Test Environment Setup
Tests use conditional compilation for VRCSDK dependencies:
- `NDMF_VRCSDK3_AVATARS` define for VRCSDK-dependent tests
- Base functionality tests work in standalone mode
- Use `#if NDMF_VRCSDK3_AVATARS` for VRCSDK-specific test code

### Example Test Pattern
```csharp
[Test]
public void TestPluginExecution()
{
    // Arrange
    var context = CreateTestBuildContext();
    
    // Act
    RunPlugin(context);
    
    // Assert
    Assert.AreEqual(expectedValue, context.GetState<TestState>().Value);
}

#if NDMF_VRCSDK3_AVATARS
[Test]
public void TestVRCSDKIntegration()
{
    // VRCSDK-specific test code
}
#endif
```

### CI Testing Information
- **GameCI Workflow**: `.github/workflows/gameci.yml`
- **Test Matrix**: Unity 2022.3.6f1 with both VRCSDK and standalone configurations
- **Coverage Reports**: Generated with assembly filter `+nadena.dev.*`
- **Artifacts**: Test results and coverage reports uploaded for debugging
- **Test Output**: Check CI logs for compilation errors and test failures

## Common Development Workflows

### Adding a New Plugin
1. Create plugin class inheriting from `Plugin<T>`
2. Implement `Configure()` method with phase declarations
3. Add `[assembly: ExportsPlugin(typeof(Plugin))]` attribute
4. Add unit tests for plugin functionality
5. Document any new public APIs
6. Update `CHANGELOG.md` and `CHANGELOG-PRERELEASE.md` with PR number citation

### Adding Extension Contexts
1. Implement `IExtensionContext` interface
2. Define context activation/deactivation logic
3. Update passes to declare required/compatible contexts
4. Add context to extension registry
5. Update changelog with PR number citation

## Documentation & Change Management

### Changelog Requirements
- All code changes must be documented in `CHANGELOG.md` and `CHANGELOG-PRERELEASE.md`
- Documentation-only changes do not need changelog entries
- Changelog entries must cite the PR number that fixed the issue
- Format: `- [#PR_NUMBER] Description`
- Feature/fix designation is indicated by section headings (### Added, ### Fixed, ### Changed, etc.)

### Public API Changes
- New public APIs require explicit justification in PR descriptions
- Breaking changes need version bump consideration
- Use `[PublicAPI]` attribute for public API surfaces
- Mark internal-only APIs with `[NDMFInternal]` attribute

### Debugging Execution Order
- Use `#if NDMF_INTERNAL_DEBUG` for debug output
- Plugin resolver logs constraint graphs in debug builds
- Check GameCI workflow logs for test execution details

## Platform Support

- Primary: VRChat platform via VRCSDK
- Experimental: Standalone platform support
- Use `[RunsOnAllPlatforms]` or platform-specific constraints
- Platform providers implement `INDMFPlatformProvider`

## Build & CI Information

### Local Development
- Unity 2022.3.6f1+ required
- Use Unity Package Manager for dependencies
- Setup scripts: `SetupUnitTests.ps1` and `SetupStandalone.ps1`
- Run tests via Unity Test Runner (EditMode) or command line
- Test assembly: `nadena.dev.ndmf.UnitTests` with Editor-only platform targeting

### CI Pipeline (GameCI)
- Automated testing on Unity 2022.3.6f1
- Matrix testing: VRCSDK and standalone configurations  
- Uses `unity-test-runner@v3` with EditMode testing
- Coverage reports with `generateAdditionalMetrics;generateHtmlReport;generateBadgeReport`
- Assembly filter: `+nadena.dev.*` for coverage
- Custom parameters: `-nographics -assemblyNames nadena.dev.ndmf.UnitTests`
- Test artifacts uploaded for debugging compilation errors and test failures

### Package Distribution
- Unity Package Manager format
- Semantic versioning (see `docfx~/versioning-policy.md`)
- Automated release builds via GitHub Actions

## Key Dependencies & Integrations

- **VRChat SDK** - Avatar descriptor and build pipeline integration
- **Unity Animation System** - Animation path tracking and modification
- **Harmony** - Runtime patching for Unity editor integration
- **Localization System** - Multi-language error reporting

### Primary Consumer Projects

- **Modular Avatar** (https://github.com/bdunderscore/modular-avatar) - The primary consumer of NDMF
  - Use Modular Avatar's codebase as a reference for real-world NDMF usage patterns
  - Test code changes against Modular Avatar's CI test suite when possible
  - Follow patterns established in Modular Avatar for plugin development

## Common Patterns to Follow

1. **State Management**: Use `BuildContext.GetState<T>()` for pass-to-pass communication
2. **Error Reporting**: Use `ErrorReport.ReportError()` with proper context objects
3. **Asset Management**: Use `AssetSaver` for generated asset cleanup
4. **Animation Handling**: Use animation services for path tracking
5. **Object Tracking**: Use `ObjectRegistry` for cross-pass object references

## Debugging Tips

- Enable `NDMF_INTERNAL_DEBUG` for verbose logging
- Check constraint graphs for dependency issues  
- Use Unity Profiler for performance analysis
- Review GameCI logs for test failures
- Use error reporting system for user-friendly diagnostics

This framework emphasizes predictable execution order, robust error handling, and extensibility while maintaining backwards compatibility.