#region

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using nadena.dev.ndmf.runtime;
using UnityEditor;
using UnityEngine;

#endregion

namespace nadena.dev.ndmf
{
    /// <summary>
    /// Provides information about VRChat Expression Parameters and animator parameters generated by NDMF-registered
    /// components. 
    /// </summary>
    public sealed class ParameterInfo
    {
        public static readonly ParameterInfo ForUI = new ParameterInfo(null);

        public static ParameterInfo ForContext(BuildContext context)
        {
            return context.GetState(ctx => new ParameterInfo(ctx));
        }

        private readonly BuildContext _context;

        public enum ConflictType
        {
            TypeMismatch
        }

        /// <summary>
        /// Invoked when multiple components provide a parameter with the same name, but with conflicting configuration.
        /// May be invoked multiple times for different conflict types. 
        /// </summary>
        public delegate void ConflictHandler(ConflictType type, ProvidedParameter p1, ProvidedParameter p2);

        [InitializeOnLoadMethod]
        static void Init()
        {
            EnhancerDatabase<ParameterProviderFor, IParameterProvider>.AsyncInit();
        }

        private ParameterInfo(BuildContext context)
        {
            _context = context;
        }

        private long _parameterCount; // used to maintain declaration order

        private struct RegisteredParameter
        {
            public ProvidedParameter Parameter;
            public long index;
        }

        /// <summary>
        /// Enumerates a GameObject and all children, querying for components which provide parameters, and returns what
        /// was found.
        /// </summary>
        /// <param name="obj">The object to query</param>
        /// <param name="onConflict">A callback to receive information about conflicting values.</param>
        /// <returns></returns>
        public IEnumerable<ProvidedParameter> GetParametersForObject(GameObject obj, ConflictHandler onConflict = null)
        {
            _parameterCount = 0;
            // Unity 2019 will break if we take any of ReSharper's suggestions here...
            
            // ReSharper disable InconsistentNaming
            // ReSharper disable UnusedParameter.Local
            // ReSharper disable ConvertToNullCoalescingCompoundAssignment
            onConflict = onConflict ?? ((_type, _p1, _p2) => { });
            // ReSharper restore ConvertToNullCoalescingCompoundAssignment
            // ReSharper restore UnusedParameter.Local
            // ReSharper restore InconsistentNaming

            return GetParametersForObject(obj, onConflict,
                    ImmutableDictionary<(ParameterNamespace, string), ParameterMapping>.Empty)
                .OrderBy(rp => rp.index)
                .Select(rp => rp.Parameter);
        }

        /// <summary>
        /// Determines what parameter name remappings are effective at a given game object. 
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public ImmutableDictionary<(ParameterNamespace, string), ParameterMapping> GetParameterRemappingsAt(
            GameObject obj)
        {
            ImmutableDictionary<(ParameterNamespace, string), ParameterMapping> mappings
                = ImmutableDictionary<(ParameterNamespace, string), ParameterMapping>.Empty;

            if (!RuntimeUtil.IsAvatarRoot(obj.transform))
            {
                mappings = GetParameterRemappingsAt(obj.transform.parent.gameObject);
            }

            foreach (var component in obj.GetComponents(typeof(Component)))
            {
                if (EnhancerDatabase<ParameterProviderFor, IParameterProvider>.Query(component, out var provider))
                {
                    provider.RemapParameters(ref mappings, _context);
                }
            }

            return mappings;
        }

        /// <summary>
        /// Determines what parameter name remappings are effective at a given component (including any mappings applied
        /// by siblings).
        /// </summary>
        /// <param name="c"></param>
        /// <param name="includeSelf">Include component c's mappings in the result</param>
        /// <returns></returns>
        public ImmutableDictionary<(ParameterNamespace, string), ParameterMapping> GetParameterRemappingsAt(Component c,
            bool includeSelf)
        {
            ImmutableDictionary<(ParameterNamespace, string), ParameterMapping> mappings
                = ImmutableDictionary<(ParameterNamespace, string), ParameterMapping>.Empty;

            if (!RuntimeUtil.IsAvatarRoot(c.transform))
            {
                mappings = GetParameterRemappingsAt(c.transform.parent.gameObject);
            }

            foreach (var component in c.GetComponents(typeof(Component)))
            {
                if (component == c && !includeSelf)
                {
                    break;
                }

                if (EnhancerDatabase<ParameterProviderFor, IParameterProvider>.Query(component, out var provider))
                {
                    provider.RemapParameters(ref mappings, _context);
                }

                if (component == c) break;
            }

            return mappings;
        }

        private IEnumerable<RegisteredParameter> GetParametersForObject(GameObject root, ConflictHandler onConflict,
            ImmutableDictionary<(ParameterNamespace, string), ParameterMapping> remaps)
        {
            Dictionary<(ParameterNamespace, string), RegisteredParameter> parameters
                = new Dictionary<(ParameterNamespace, string), RegisteredParameter>();

            foreach (var component in root.GetComponents<Component>())
            {
                if (!EnhancerDatabase<ParameterProviderFor, IParameterProvider>.Query(component, out var provider))
                {
                    continue;
                }

                // Apply mappings first
                provider.RemapParameters(ref remaps, _context);

                // Collect parameters
                foreach (var newParameter in provider.GetSuppliedParameters(_context))
                {
                    if (remaps.TryGetValue(newParameter.NamePair, out var singleRemap))
                    {
                        newParameter.EffectiveName = singleRemap.ParameterName;
                        newParameter.IsHidden = newParameter.IsHidden || singleRemap.IsHidden;
                    }

                    if (parameters.TryGetValue(newParameter.NamePair, out var existingParam))
                    {
                        ResolveConflict(onConflict, existingParam, newParameter, false);
                    }
                    else
                    {
                        parameters[newParameter.NamePair] = new RegisteredParameter
                        {
                            Parameter = newParameter,
                            index = _parameterCount++
                        };
                    }
                }
            }

            Dictionary<(ParameterNamespace, string), RegisteredParameter> childParameters = CollectChildParams(root, onConflict, remaps);

            foreach (var kvp in childParameters)
            {
                if (parameters.TryGetValue(kvp.Key, out var existingParam))
                {
                    ResolveConflict(onConflict, existingParam, kvp.Value.Parameter, true);
                }
                else
                {
                    parameters[kvp.Key] = kvp.Value;
                }
            }

            return parameters.Values;
        }

        private Dictionary<(ParameterNamespace, string), RegisteredParameter> CollectChildParams(GameObject root, ConflictHandler onConflict,
            ImmutableDictionary<(ParameterNamespace, string), ParameterMapping> remaps)
        {
            Dictionary<(ParameterNamespace, string), RegisteredParameter> parameters = new Dictionary<(ParameterNamespace, string), RegisteredParameter>();

            foreach (Transform childTransform in root.transform)
            {
                var childParams = GetParametersForObject(childTransform.gameObject, onConflict, remaps);

                foreach (var rp in childParams)
                {
                    if (parameters.TryGetValue(rp.Parameter.NamePair, out var existingParam))
                    {
                        ResolveConflict(onConflict, existingParam, rp.Parameter, false);
                    }
                    else
                    {
                        parameters[rp.Parameter.NamePair] = rp;
                    }
                }
            }

            return parameters;
        }

        private void ResolveConflict(ConflictHandler onConflict, RegisteredParameter oldP, ProvidedParameter newP,
            bool isParentChild)
        {
            if (oldP.Parameter.ParameterType != newP.ParameterType)
            {
                if ((oldP.Parameter.ParameterType == null) != (newP.ParameterType == null))
                {
                    oldP.Parameter.ParameterType = oldP.Parameter.ParameterType ?? newP.ParameterType;
                }
                else if (oldP.Parameter.IsAnimatorOnly && newP.IsAnimatorOnly)
                {
                    // ignore the conflict; we'll resolve everything to float in the animator if needed
                }
                else if (!oldP.Parameter.IsAnimatorOnly && !newP.IsAnimatorOnly)
                {
                    // Flag conflict and resolve to oldP's parameter type
                    onConflict(ConflictType.TypeMismatch, oldP.Parameter, newP);
                }
                else if (!newP.IsAnimatorOnly)
                {
                    // Update type to match the non-animator-only value in newP
                    oldP.Parameter.ParameterType = newP.ParameterType;
                }
            }

            oldP.Parameter.IsAnimatorOnly &= newP.IsAnimatorOnly;
            oldP.Parameter.IsHidden &= newP.IsHidden;
            oldP.Parameter.WantSynced = oldP.Parameter.WantSynced || newP.WantSynced;
        }
    }
}